GIL锁
===
## 引题

写一个死循环
```python
i = 0
while True:
    i += 0
```
上诉死循环代码的C、Java实现会让CPU100%，但python实现cpu占用率只有30%-50%。说明python代码无法完全发挥cpu的性能。原因是GIL锁的存在。

## GIL锁产生历史
GIL(global interpreter lock)全局解释器锁。python设计之初，家用电脑还都是单核cpu。另一方面为了解释器设计简单（内存回收）和数据安全。
python中某个线程想要执行，先要拿到GIL锁（好像程序运行的通行证），才会被允许进入cpu执行命令。当这个线程一段指令执行完毕后，被cpu挂起，释放解释器GIL锁，让后其他线程再争夺gil锁，取得锁后进入cpu调度。
python解释器默认cpython，c线程不能直接操作cpu，只能被gil锁控制，同一时间只能一个线程。所以python程序只能让cpu的一个核心满载。（课外）pypy jpython没有GIL锁，运行效率较高。

## 建议和场景
1. 避免cpu密集型程序。例如水利、航天轨道、圆周率、找素数等。
2. 适合IO密集型。例如下载图片、写数据库等。

目前网站需求主要是IO密集型，平时任务cpu性能过剩、主要缺硬盘性能，固态硬盘出现大大提升体验。平时爬虫、网站、轻度计算，python完全可以胜任。
目 前大多数软件的瓶颈还是网络带宽、数据库读写、硬盘。  

建议：使用多进程提高cpu利用率。好像影分身。
例如gunicorion多开几个进程运行django程序。

GIL锁在py3中有所改进；
在py2中只有一个gil锁，要么获取要么释放，没有锁的线程要等待。
在py3中tocks计数GIL锁，达到一定时间后再释放，对cpu密集型程序更加友好。但仍没解决同一时间只能执行一个线程。

由于生态已经建立，所以解释器底层不敢有大改动。